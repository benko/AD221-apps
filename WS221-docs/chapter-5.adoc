= Chapter 5

== Integrating Services using Asynchronous Messaging

Let's go through the next GE to give an example for proper connection with ActiveMQ

=== Guided Exercise: Integrating Services Using JMS

We'll use the next Guided Exercise (Testing Camel Routes with Camel Test Kit) as
sample for how to setup Unit Tests with Camel Quarkus.

[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-junit5</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-junit5</artifactId>
    <scope>test</scope>
</dependency>
----

As noted in the Student Guide the libraries are replaced with _camel-test-junit5_ and with _camel-quarkus-junit5_ instead of _camel-test-spring-junit5_ as we're using Camel 3 with the Quarkus integration in this workshop.

=== Configuring Camel Testing in Camel Quarkus
To create proper tests equivalent to _CamelTestSupport_ we're creating JUnit 5 tests running with the _QuarkusTestExtension_. We're activating it using the _@QuarkusTest_ annotation and the base class _CamelQuarkusTestSupport_ as follows:

[source,java]
----
@QuarkusTest
class HtmlRouteBuilderTest extends CamelQuarkusTestSupport {
}
----

To configure the RouteBuilders we want to use and test in our unit tests we need to implement one of the following base methods depending on the need for one or multiple RoutesBuilders:

[source,java]
----
protected RoutesBuilder createRouteBuilder() throws Exception;

protected RoutesBuilder[] createRouteBuilders() throws Exception;
----

It's also necessary to disable the automatic detection of all RouteBuilders that is active in normal operation in camel quarkus. We'll do so by providing an extra _application.properties_ in the test resources:

[source,properties]
----
quarkus.camel.routes-discovery.enabled=false
----

In Quarkus all injections use the _@Inject_ annotation and the fields must not be private:

[source,java]
----
@Inject
protected ProducerTemplate producerTemplate;

@Inject
protected ConsumerTemplate consumerTemplate;
----

=== Guided Exercise: Testing Camel Routes with Camel Test Kit

4.1: The necessary dependencies are as follows:

[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-junit5</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-junit5</artifactId>
    <scope>test</scope>
</dependency>
----

7.1: Add the _@QuarkusTest_ annotation to the test class.

=== Testing Using Mock Endpoints (Guided Exercise)


The endpoints we want to used are injected into Camel 3 tests as follows:

[source,java]
----
@EndpointInject("mock:http:localhost")
protected MockEndpoint httpMockEndpoint;

@EndpointInject("mock:file:out")
protected MockEndpoint fileMockEndpoint;
----

The advice code must look as follows when using Camel Quarkus:

[source,java]
----
@BeforeEach
void doAdvice() throws Exception {
    AdviceWith.adviceWith(context(), "http-route", this::adviceRoute);
}

private void adviceRoute(AdviceWithRouteBuilder route) {
    route.interceptSendToEndpoint("http://localhost/greeting")
         .skipSendToOriginalEndpoint()
         .to("mock:http:localhost");
    route.interceptSendToEndpoint("file:out?fileName=response.txt")
         .skipSendToOriginalEndpoint()
         .to("mock:file:out");
}
----

As in the GE before the _createRouteBuilder()_ method is used to define which Routes to create.

===  Handling Errors in Camel

(Works as described in the student guide.)

=== Guided Exercise: Handling Errors in Camel

(Works as described in the student guide except starting the application using _mvn quarkus:dev_ as usual)

===  Integrating Services Using JMS

Instead of using the jms and the amqp component we're going to use just the amqp component as this is much easier to configure.

This means we don't need to provide a JmsComponent factory.

Instead we simply configure the amqp component by setting the following tree properties:

[source,properties]
----
quarkus.qpid-jms.url = amqp://localhost:5672
quarkus.qpid-jms.username = admin
quarkus.qpid-jms.password = admin
----

== Warning!

Unfortunalety at the moment there is a bug in the test setup so that the tests aren't independent and cannot be run together.
Instead they need to be run subsequently.

=== Guided Exercise: Integrating Services Using AMQ

5.1

Actually we only need to add one dependency:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-amqp</artifactId>
</dependency>
----

Also, we're always using the "amqp" component. So replace _jms:queue_ with _amqp:queue_ in the RouteBuilders.

The connection configuration is the easily done in the application.properties file:

[source,properties]
----
quarkus.qpid-jms.url = amqp://localhost:5672
%test.quarkus.qpid-jms.url = amqp://localhost:61616
quarkus.qpid-jms.username = admin
quarkus.qpid-jms.password = admin
----

===  Integrating Camel with Kafka

We're going to use a different test setup for this one that will be explained in the guided exercise.

As dependencies we'll only need to add one for Kafka:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-kafka</artifactId>
</dependency>
----

Config properties for Kafka in testing will be:

[source,properties]
----
camel.component.kafka.configuration.auto-offset-reset=earliest
camel.component.kafka.configuration.value-deserializer=com.redhat.training.emergency.serde.LocationDeserializer
----

=== Guided Exercise: Integrating Camel with Kafka

In contrast to the old GE we have two major differences here:

- We're only going to use the Kafka componennt, no jdbc and no mysql database (this will be done in the next chapter).
- We're using the builtin testcontainers support of Quarkus which simplifies the unit testing of various servers.

Regarding dependencies we're going to use:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-kafka</artifactId>
</dependency>
----

and for testing:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-integration-tests-support-kafka</artifactId>
    <version>2.15.0</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>kafka</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </exclusion>
    </exclusions>
</dependency>
----

To use the testcontainers-setup together with _podman_ on our workstation we need to tweek the configuration a little. First the podman socket service needs to be activated as a user service as follows (second command will show the status):

[source,bash]
----
systemctl --user enable --now podman.socket
systemctl status podman.socket
----

Additionally the following variables need to be set in the shell running the tests. This is best added to _.bashrc_:

[source,bash]
----
export DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock
export TESTCONTAINERS_RYUK_DISABLED=true
----

On a system running dockerd as probably on you own development systems nothing needs to be tweeked.

In our example we're just forwarding the data to a log output and then replace the log route with:

[source,java]
----
route.interceptSendToEndpoint("direct:logger")
    .skipSendToOriginalEndpoint()
    .to("mock:file:logger");
----

So we can test the forwarding of the messages.

